<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodePrompt AI Terminal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            font-size: 13px;
            overflow: auto;
        }
        
        .terminal-header {
            background: #1a1a1a;
            color: white;
            padding: 6px 10px;
            font-size: 11px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .terminal-buttons {
            display: flex;
            gap: 4px;
        }
        
        .btn {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: none;
        }
        
        .btn.close { background: #ff5f57; }
        .btn.minimize { background: #ffbd2e; }
        .btn.maximize { background: #28ca42; }
        
        .terminal-title {
            color: #888;
            margin-left: 6px;
        }
        
        .terminal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: auto;
        }
        
        .terminal-output {
            flex: 1;
            padding: 10px;
            padding-bottom: 60px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.2;
            white-space: pre-wrap;
        }
        
        .terminal-input {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #1a1a1a;
            padding: 8px 10px;
            border-top: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .prompt {
            color: #00ff00;
            font-weight: bold;
        }
        
        .input-field {
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            outline: none;
            flex: 1;
            caret-color: #00ff00;
        }
        
        .message {
            margin-bottom: 4px;
        }
        
        .user-message {
            color: #00ff00;
        }
        
        .bot-message {
            color: white;
        }
        
        .ai-message {
            color: #00bfff;
            border-left: 3px solid #00bfff;
            padding-left: 8px;
            margin: 8px 0;
        }
        
        .error {
            color: #ff5555;
        }
        
        .success {
            color: #55ff55;
        }
        
        .warning {
            color: #ffff55;
        }
        
        .crypto-data {
            margin: 4px 0;
            border: 1px solid #333;
            background: #0a0a0a;
        }
        
        .crypto-header {
            background: #1a1a1a;
            color: #00ff00;
            padding: 4px 8px;
            font-weight: bold;
            border-bottom: 1px solid #333;
        }
        
        .crypto-body {
            padding: 6px 8px;
        }
        
        .crypto-row {
            display: flex;
            justify-content: space-between;
            margin: 1px 0;
        }
        
        .positive {
            color: #55ff55;
        }
        
        .negative {
            color: #ff5555;
        }
        
        .chart {
            font-family: 'Courier New', monospace;
            color: #666;
            margin: 4px 0;
        }
        
        .ascii-art {
            color: #888;
            font-size: 11px;
            line-height: 1;
            margin: 6px 0;
        }
        
        .typing-indicator {
            color: #888;
            display: inline-block;
        }
        
        .typing-dots::after {
            content: '...';
            animation: typing 1.5s infinite;
        }
        
        @keyframes typing {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
            100% { content: '.'; }
        }
        
        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #333 #000;
        }
        
        .scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        
        .scrollbar::-webkit-scrollbar-track {
            background: #000;
        }
        
        .scrollbar::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }
        
        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .compact-list {
            margin: 2px 0;
        }
        
        .compact-row {
            display: flex;
            justify-content: space-between;
            padding: 1px 0;
        }

        .ai-thinking {
            color: #666;
            font-style: italic;
        }

        .recommendation {
            background: #001133;
            border: 1px solid #0066cc;
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
        }

        .recommendation-header {
            color: #00bfff;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .live-data {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="terminal-header">
        <div class="terminal-buttons">
            <button class="btn close"></button>
            <button class="btn minimize"></button>
            <button class="btn maximize"></button>
        </div>
        <div class="terminal-title">nodeprompt@ai-terminal:~$</div>
    </div>
    
    <div class="terminal-body">
        <div class="terminal-output scrollbar" id="output">
            <div class="message bot-message">NodePrompt AI Terminal v2.0.0</div>
            <div class="message bot-message">ðŸ¤– AI Assistant + ðŸ“Š Live Crypto Data + ðŸ”„ Real-time Updates</div>
            <div class="message bot-message">Built by @adamtappedin</div>
            <div class="message bot-message">â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</div>
        </div>
        
        <div class="terminal-input">
            <span class="prompt">nodeprompt@ai-terminal:~$ </span>
            <input type="text" class="input-field" id="commandInput" autocomplete="off" spellcheck="false" placeholder="Try: ai analyze bitcoin, live btc, or help">
        </div>
    </div>

    <script>
        const API_KEY = 'CG-EJg28u9CCZB4i7aQphoDJQKw';
        const output = document.getElementById('output');
        const commandInput = document.getElementById('commandInput');
        
        let isProcessing = false;
        let liveUpdates = new Map(); // Store live update intervals
        let cryptoCache = new Map(); // Cache recent crypto data
        
        // AI Analysis Functions
        const AI_RESPONSES = {
            bullish_signals: [
                "Strong upward momentum detected",
                "Breaking key resistance levels",
                "Volume surge indicating accumulation",
                "Technical indicators showing bullish divergence"
            ],
            bearish_signals: [
                "Bearish divergence in momentum",
                "Breaking below key support",
                "Decreasing volume on rallies",
                "Overbought conditions present"
            ],
            neutral_signals: [
                "Consolidation phase detected",
                "Mixed signals from indicators",
                "Range-bound trading pattern",
                "Awaiting catalyst for direction"
            ]
        };

        // Enhanced crypto analysis
        function analyzeMarketSentiment(cryptoData) {
            const change24h = cryptoData.price_change_percentage_24h;
            const volume = cryptoData.total_volume;
            const marketCap = cryptoData.market_cap;
            
            let sentiment = 'neutral';
            let confidence = 50;
            let signals = [];
            
            if (change24h > 5) {
                sentiment = 'bullish';
                confidence = Math.min(90, 60 + Math.abs(change24h));
                signals = AI_RESPONSES.bullish_signals;
            } else if (change24h < -5) {
                sentiment = 'bearish';
                confidence = Math.min(90, 60 + Math.abs(change24h));
                signals = AI_RESPONSES.bearish_signals;
            } else {
                signals = AI_RESPONSES.neutral_signals;
                confidence = 40 + Math.random() * 20;
            }
            
            return {
                sentiment: sentiment.toUpperCase(),
                confidence: confidence.toFixed(0),
                signal: signals[Math.floor(Math.random() * signals.length)],
                riskLevel: change24h > 10 || change24h < -10 ? 'HIGH' : 'MODERATE'
            };
        }

        function generateAIRecommendation(cryptoData) {
            const analysis = analyzeMarketSentiment(cryptoData);
            const price = cryptoData.current_price;
            
            let action, reason, target;
            
            if (analysis.sentiment === 'BULLISH') {
                action = Math.random() > 0.5 ? 'BUY' : 'HOLD';
                reason = 'Strong upward momentum with high volume';
                target = (price * (1 + Math.random() * 0.2 + 0.05)).toFixed(2);
            } else if (analysis.sentiment === 'BEARISH') {
                action = Math.random() > 0.3 ? 'SELL' : 'AVOID';
                reason = 'Downward pressure with weak support';
                target = (price * (1 - Math.random() * 0.15 - 0.05)).toFixed(2);
            } else {
                action = 'HOLD';
                reason = 'Consolidation phase - wait for clear direction';
                target = price.toFixed(2);
            }
            
            return { action, reason, target, analysis };
        }

        // Handle keyboard input
        commandInput.addEventListener('keydown', function(event) {
            if (event.key === 'Enter' && !isProcessing) {
                const command = commandInput.value.trim();
                if (command) {
                    executeCommand(command);
                    commandInput.value = '';
                }
            }
        });
        
        function printMessage(message, type = 'bot') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            messageDiv.textContent = message;
            output.appendChild(messageDiv);
            scrollToBottom();
        }
        
        function printHTML(html) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot-message';
            messageDiv.innerHTML = html;
            output.appendChild(messageDiv);
            scrollToBottom();
        }

        function printAIMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai-message';
            messageDiv.innerHTML = `ðŸ¤– AI: ${message}`;
            output.appendChild(messageDiv);
            scrollToBottom();
        }

        function printRecommendation(rec) {
            const recDiv = document.createElement('div');
            recDiv.className = 'recommendation';
            recDiv.innerHTML = `
                <div class="recommendation-header">ðŸŽ¯ AI RECOMMENDATION</div>
                <div>Action: <span class="${rec.action === 'BUY' ? 'positive' : rec.action === 'SELL' ? 'negative' : 'warning'}">${rec.action}</span></div>
                <div>Target: $${rec.target}</div>
                <div>Reason: ${rec.reason}</div>
                <div>Sentiment: ${rec.analysis.sentiment} (${rec.analysis.confidence}% confidence)</div>
                <div>Risk Level: ${rec.analysis.riskLevel}</div>
                <div>Signal: ${rec.analysis.signal}</div>
            `;
            output.appendChild(recDiv);
            scrollToBottom();
        }
        
        function printUserCommand(command) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.textContent = `nodeprompt@ai-terminal:~$ ${command}`;
            output.appendChild(messageDiv);
            scrollToBottom();
        }
        
        function generateCryptoArt(symbol) {
            const artMap = {
                'BTC': `
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  â–ˆâ–ˆ        â–ˆâ–ˆ
 â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ  â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ
â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ
 â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ
  â–ˆâ–ˆ        â–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`,
                'ETH': `
      â–ˆâ–ˆâ–ˆâ–ˆ
     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   â–ˆâ–ˆ      â–ˆâ–ˆ
  â–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆ
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`,
                'ADA': `
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
   â–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆ
  â–ˆâ–ˆâ–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆ
 â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ
â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ
â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ
 â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ
  â–ˆâ–ˆâ–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆ
   â–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆ
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`,
                'SOL': `
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
â–ˆâ–ˆ              â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ
â–ˆâ–ˆ              â–ˆâ–ˆ
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`,
                'DEFAULT': `
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
 â–ˆâ–ˆ          â–ˆâ–ˆ
â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ  â–ˆâ–ˆ
â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ  â–ˆâ–ˆ
â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ
 â–ˆâ–ˆ          â–ˆâ–ˆ
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ`
            };
            
            return artMap[symbol.toUpperCase()] || artMap['DEFAULT'];
        }
        
        function generatePriceChart(changePercent) {
            const isPositive = changePercent >= 0;
            const absChange = Math.abs(changePercent);
            const barLength = Math.min(Math.floor(absChange / 2), 20);
            
            let chart = '';
            if (isPositive) {
                chart = 'â–² ' + 'â–ˆ'.repeat(barLength) + 'â–‘'.repeat(20 - barLength) + ' +' + changePercent.toFixed(2) + '%';
            } else {
                chart = 'â–¼ ' + 'â–ˆ'.repeat(barLength) + 'â–‘'.repeat(20 - barLength) + ' ' + changePercent.toFixed(2) + '%';
            }
            
            return `<div class="chart ${isPositive ? 'positive' : 'negative'}">${chart}</div>`;
        }
        
        function printCryptoData(data, isLive = false) {
            const changeClass = data.price_change_percentage_24h >= 0 ? 'positive' : 'negative';
            const changeSymbol = data.price_change_percentage_24h >= 0 ? '+' : '';
            const art = generateCryptoArt(data.symbol);
            const chart = generatePriceChart(data.price_change_percentage_24h);
            const liveIndicator = isLive ? '<span class="live-data">ðŸ”´ LIVE</span>' : '';
            
            const cryptoDiv = document.createElement('div');
            cryptoDiv.className = 'crypto-data';
            cryptoDiv.id = isLive ? `live-${data.symbol.toLowerCase()}` : '';
            
            cryptoDiv.innerHTML = `
                <div class="crypto-header">${data.name.toUpperCase()} (${data.symbol.toUpperCase()}) ${liveIndicator}</div>
                <div class="crypto-body">
                    <div class="ascii-art">${art}</div>
                    <div class="crypto-row"><span>Price:    $${data.current_price.toLocaleString()}</span></div>
                    <div class="crypto-row"><span>24h:    <span class="${changeClass}">${changeSymbol}${data.price_change_percentage_24h.toFixed(2)}%</span></div>
                    ${chart}
                    <div class="crypto-row"><span>MCap:    $${(data.market_cap / 1e9).toFixed(2)}B</span></div>
                    <div class="crypto-row"><span>Vol:    $${(data.total_volume / 1e6).toFixed(2)}M</span></div>
                    ${isLive ? '<div class="crypto-row"><span style="color: #666;">Updated: ' + new Date().toLocaleTimeString() + '</span></div>' : ''}
                </div>
            `;
            
            if (isLive) {
                const existing = document.getElementById(`live-${data.symbol.toLowerCase()}`);
                if (existing) {
                    existing.replaceWith(cryptoDiv);
                } else {
                    output.appendChild(cryptoDiv);
                }
            } else {
                output.appendChild(cryptoDiv);
            }
            
            scrollToBottom();
        }
        
        function printCompactList(cryptos) {
            const listDiv = document.createElement('div');
            listDiv.className = 'compact-list';
            
            let html = '<div style="color: #888; margin-bottom: 4px;">RANK | NAME        | PRICE      | 24H     | MCAP</div>';
            html += '<div style="color: #333; margin-bottom: 4px;">-----|-------------|------------|--------|--------</div>';
            
            cryptos.forEach((crypto, index) => {
                const changeClass = crypto.price_change_percentage_24h >= 0 ? 'positive' : 'negative';
                const changeSymbol = crypto.price_change_percentage_24h >= 0 ? '+' : '';
                const rank = (index + 1).toString().padStart(2, ' ');
                const name = crypto.symbol.toUpperCase().padEnd(11, ' ');
                const price = ('$' + crypto.current_price.toLocaleString()).padEnd(10, ' ');
                const change = (changeSymbol + crypto.price_change_percentage_24h.toFixed(1) + '%').padEnd(7, ' ');
                const mcap = ('$' + (crypto.market_cap / 1e9).toFixed(1) + 'B').padEnd(8, ' ');
                
                html += `<div class="compact-row">${rank}   | ${name} | ${price} | <span class="${changeClass}">${change}</span> | ${mcap}</div>`;
            });
            
            listDiv.innerHTML = html;
            output.appendChild(listDiv);
            scrollToBottom();
        }
        
        function showTyping(message = 'Processing') {
            isProcessing = true;
            commandInput.disabled = true;
            
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message typing-indicator';
            typingDiv.id = 'typing';
            typingDiv.innerHTML = `${message}<span class="typing-dots"></span>`;
            output.appendChild(typingDiv);
            scrollToBottom();
        }
        
        function hideTyping() {
            const typing = document.getElementById('typing');
            if (typing) typing.remove();
            
            isProcessing = false;
            commandInput.disabled = false;
            commandInput.focus();
        }
        
        function scrollToBottom() {
            output.scrollTop = output.scrollHeight;
        }
        
        async function fetchCryptoData(coinId) {
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}?x_cg_demo_api_key=${API_KEY}`);
                if (!response.ok) throw new Error('API request failed');
                return await response.json();
            } catch (error) {
                console.error('Error fetching crypto data:', error);
                return null;
            }
        }
        
        async function fetchTopCryptos(limit = 10) {
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=1&sparkline=false&x_cg_demo_api_key=${API_KEY}`);
                if (!response.ok) throw new Error('API request failed');
                return await response.json();
            } catch (error) {
                console.error('Error fetching top cryptos:', error);
                return null;
            }
        }
        
        function getCoinId(query) {
            const commonCoins = {
                'bitcoin': 'bitcoin', 'btc': 'bitcoin',
                'ethereum': 'ethereum', 'eth': 'ethereum',
                'cardano': 'cardano', 'ada': 'cardano',
                'solana': 'solana', 'sol': 'solana',
                'xrp': 'ripple', 'ripple': 'ripple',
                'dogecoin': 'dogecoin', 'doge': 'dogecoin',
                'litecoin': 'litecoin', 'ltc': 'litecoin',
                'chainlink': 'chainlink', 'link': 'chainlink',
                'polkadot': 'polkadot', 'dot': 'polkadot',
                'binancecoin': 'binancecoin', 'bnb': 'binancecoin'
            };
            
            return commonCoins[query.toLowerCase()] || query.toLowerCase();
        }

        // Live updates functionality
        function startLiveUpdates(coinId, symbol) {
            // Stop existing updates for this coin
            if (liveUpdates.has(symbol)) {
                clearInterval(liveUpdates.get(symbol));
            }

            // Start new live updates every 30 seconds
            const interval = setInterval(async () => {
                const data = await fetchCryptoData(coinId);
                if (data) {
                    const coinData = {
                        name: data.name,
                        symbol: data.symbol,
                        current_price: data.market_data.current_price.usd,
                        price_change_percentage_24h: data.market_data.price_change_percentage_24h,
                        market_cap: data.market_data.market_cap.usd,
                        total_volume: data.market_data.total_volume.usd
                    };
                    cryptoCache.set(symbol, coinData);
                    printCryptoData(coinData, true);
                }
            }, 30000);

            liveUpdates.set(symbol, interval);
            printMessage(`ðŸ”´ Live updates started for ${symbol.toUpperCase()} (30s intervals)`, 'success');
        }

        function stopLiveUpdates(symbol = null) {
            if (symbol) {
                if (liveUpdates.has(symbol)) {
                    clearInterval(liveUpdates.get(symbol));
                    liveUpdates.delete(symbol);
                    printMessage(`ðŸ”´ Live updates stopped for ${symbol.toUpperCase()}`, 'warning');
                } else {
                    printMessage(`No live updates found for ${symbol.toUpperCase()}`, 'error');
                }
            } else {
                // Stop all live updates
                liveUpdates.forEach((interval) => clearInterval(interval));
                liveUpdates.clear();
                printMessage('ðŸ”´ All live updates stopped', 'warning');
            }
        }
        
        async function executeCommand(command) {
            printUserCommand(command);
            
            const cmd = command.toLowerCase().trim();
            const args = cmd.split(' ');
            
            if (cmd === 'help') {
                printMessage('Available commands:');
                printMessage('  help              - Show this help');
                printMessage('  price <coin>      - Get crypto price');
                printMessage('  top [number]      - Top cryptos (default: 10)');
                printMessage('  market            - Market overview');
                printMessage('  ai <question>     - Ask AI about crypto');
                printMessage('  ai analyze <coin> - AI analysis of coin');
                printMessage('  live <coin>       - Start live updates');
                printMessage('  stop [coin]       - Stop live updates');
                printMessage('  compare <coin1> <coin2> - Compare cryptos');
                printMessage('  clear             - Clear terminal');
                printMessage('  exit              - Exit');
                printMessage('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
            }
            else if (cmd === 'clear') {
                output.innerHTML = '';
                // Stop all live updates when clearing
                liveUpdates.forEach((interval) => clearInterval(interval));
                liveUpdates.clear();
            }
            else if (cmd === 'exit') {
                // Stop all live updates before exit
                liveUpdates.forEach((interval) => clearInterval(interval));
                liveUpdates.clear();
                printMessage('Live updates stopped. Connection closed.', 'error');
                commandInput.disabled = true;
            }
            else if (args[0] === 'stop') {
                if (args[1]) {
                    stopLiveUpdates(args[1].toUpperCase());
                } else {
                    stopLiveUpdates();
                }
            }
            else if (args[0] === 'live' && args[1]) {
                showTyping('Starting live updates');
                const coinId = getCoinId(args[1]);
                const data = await fetchCryptoData(coinId);
                
                hideTyping();
                if (data) {
                    const coinData = {
                        name: data.name,
                        symbol: data.symbol,
                        current_price: data.market_data.current_price.usd,
                        price_change_percentage_24h: data.market_data.price_change_percentage_24h,
                        market_cap: data.market_data.market_cap.usd,
                        total_volume: data.market_data.total_volume.usd
                    };
                    cryptoCache.set(data.symbol.toUpperCase(), coinData);
                    printCryptoData(coinData, true);
                    startLiveUpdates(coinId, data.symbol.toUpperCase());
                } else {
                    printMessage(`Error: '${args[1]}' not found`, 'error');
                }
            }
            else if (args[0] === 'price' && args[1]) {
                showTyping();
                const coinId = getCoinId(args[1]);
                const data = await fetchCryptoData(coinId);
                
                hideTyping();
                if (data) {
                    const coinData = {
                        name: data.name,
                        symbol: data.symbol,
                        current_price: data.market_data.current_price.usd,
                        price_change_percentage_24h: data.market_data.price_change_percentage_24h,
                        market_cap: data.market_data.market_cap.usd,
                        total_volume: data.market_data.total_volume.usd
                    };
                    printCryptoData(coinData);
                } else {
                    printMessage(`Error: '${args[1]}' not found`, 'error');
                }
            }
            else if (args[0] === 'ai' && args[1] === 'analyze' && args[2]) {
                showTyping('AI analyzing');
                const coinId = getCoinId(args[2]);
                const data = await fetchCryptoData(coinId);
                
                hideTyping();
                if (data) {
                    const coinData = {
                        name: data.name,
                        symbol: data.symbol,
                        current_price: data.market_data.current_price.usd,
                        price_change_percentage_24h: data.market_data.price_change_percentage_24h,
                        market_cap: data.market_data.market_cap.usd,
                        total_volume: data.market_data.total_volume.usd
                    };
                    
                    printCryptoData(coinData);
                    
                    // Simulate AI thinking
                    const thinkingDiv = document.createElement('div');
                    thinkingDiv.className = 'ai-thinking';
                    thinkingDiv.textContent = 'ðŸ¤– AI analyzing market patterns and indicators...';
                    output.appendChild(thinkingDiv);
                    scrollToBottom();
                    
                    setTimeout(() => {
                        thinkingDiv.remove();
                        const recommendation = generateAIRecommendation(coinData);
                        printRecommendation(recommendation);
                        
                        printAIMessage(`Based on technical analysis, ${coinData.name} shows ${recommendation.analysis.sentiment.toLowerCase()} signals with ${recommendation.analysis.confidence}% confidence. ${recommendation.analysis.signal}`);
                    }, 2000);
                } else {
                    printMessage(`Error: '${args[2]}' not found`, 'error');
                }
            }
            else if (args[0] === 'ai' && args.length > 1) {
                showTyping('AI thinking');
                
                // Simulate AI response delay
                setTimeout(() => {
                    hideTyping();
                    const question = args.slice(1).join(' ');
                    
                    // Simple AI responses based on keywords
                    let response = "I'm a crypto-focused AI assistant. ";
                    
                    if (question.includes('bitcoin') || question.includes('btc')) {
                        response += "Bitcoin remains the dominant cryptocurrency with strong institutional adoption. Consider its high volatility and market correlation when making decisions.";
                    } else if (question.includes('ethereum') || question.includes('eth')) {
                        response += "Ethereum's smart contract capabilities and DeFi ecosystem make it a key player
